@startuml
class Game{
 - Board: board
 - Player: player1
 - Player: player2

 + startGame()
}

abstract class Board{
-boardSquare : list<Square>
-pieceMap: Map<BoardSquare , ChessPiece>
}

class Square{
- Location: location
- SquareColor : squareColor
- isOccupied : boolean
+ reset()
+ getters and setters()

}
enum SquareColor{
BLACK, WHITE
}

class Location{
- Stack: stack
- int: column

}
enum Stack{
A, B, C, D, E, F, G, H
}
class ChessPiece{
- PieceColor: pieceColor
- Square: currentSquare
- String: name

+ getters()
+ setters()
}
enum PieceColor{
    WHITE , BLACK
}

enum PieceType{
PAWN, KNIGHT, KING , QUEEN, BISHOP, ROOK
}

abstract class GameRules{
- List<PieceType> type
- nbrOfColumns: int
- Stack: stack
- initialPositionMap: Map<BoardSquare , Piece>
    + checkMate()
    + check()
    + staleMate()
}
class RegularChessRules extends GameRules{}
class Player{
 -String: name
 -int: nbrOfWins
 -int: nbrOfMatches
 -boolean: isFirst
 +getters and setters()
}

class PieceMovementValidator {
 - pieceMovementMap : Map<PieceType , MovementValidator>
}

interface MovementValidator{
+ getValidMoves(board)
+ getValidMoves(Board board , Square square)
+ void makeMove(square)
}
class ComposedMovement implements MovementValidator{
- list<MovementValidator> movementValidator
+ isValidMovement(Square, Square) boolean
}
class ConcreteMovement implements MovementValidator{
+ isValidMovement(square , Square) boolean
}
Square <-- SquareColor
Square <-- Location
Location <-- Stack
Board <-- Square
ChessPiece <-- GameRules
ChessPiece <-- PieceColor
Game <-- Board
ChessPiece <-- Board
Game --> GameRules
Game <-- Player
ChessPiece *-- PieceType
PieceMovementValidator --> PieceType
PieceMovementValidator --> MovementValidator
@enduml